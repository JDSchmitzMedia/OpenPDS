var Collection = require('deployd/lib/resources/collection');
var util = require('util');
var http = require('http');

function AnswerCollection(name, options) {
  Collection.apply(this, arguments);
}

function OAuthServerCallback(ctx, callback){
var scope_array = new Array();
var options = {
    host: 'celldata.media.mit.edu',
    port: 8041,
    path: '/get_key_from_token?bearer_token='+ctx.query.bearer_token+'&scope=funf_write',
    method: 'GET'
  };
  var req = http.get(options, function(res) {
    var pageData = "";
    res.setEncoding('utf8');
    res.on('data', function (chunk) {
      pageData += chunk;
    });

    res.on('end', function(){
      var obj = {}
      try
      {
        obj = JSON.parse(pageData);
        var len = obj.scopes.length;
        for (var i = 0; i < len; i++)
        {
          scope_array[i] = { 'key': obj.scopes[i] };
        }
        callback(scope_array);
      }
      catch(err)
      {
        throw ctx.done(obj);
      }
    });
  });
}


AnswerCollection.events  = Collection.events;
AnswerCollection.external = Collection.external;

util.inherits(AnswerCollection, Collection);
module.exports = AnswerCollection;

AnswerCollection.prototype.handle = function (ctx, next) {
  // set id one wasnt provided in the query
  ctx.query.id = ctx.query.id || this.parseId(ctx) || (ctx.body && ctx.body.id);

  if (ctx.req.method == "GET" && ctx.query.id === 'count') {
    delete ctx.query.id;
    this.count(ctx, ctx.done);
    return;
  }

  if (ctx.req.method == "GET" && ctx.query.id === 'index-of') {
    delete ctx.query.id;
    var id = ctx.url.split('/').filter(function(p) { return p; })[1];
    this.indexOf(id, ctx, ctx.done);
    return;
  }


  switch(ctx.req.method) {
    case 'GET':
      var old_this = this;
      var old_ctx = ctx;
      ctx = old_ctx;
      if(!ctx.req.isRoot)
      {
        try
        {
          OAuthServerCallback(ctx, function(scope_array){
            ctx.query = { $and: [{ $or: scope_array}, {issharing: true}] };
            old_this.find(ctx, ctx.done);
          });
         }
         catch(err)
         {
           ctx.done(err, {'error':'failed oauth callback'});
         }
      }
      else
      {
        old_this.find(ctx, ctx.done);
      }
//      this.find(ctx, ctx.done);
    break;
    case 'PUT':
      if (typeof ctx.query.id != 'string' && !ctx.req.isRoot) {
        ctx.done("must provide id to update an object");
        break;
      }
    /* falls through */
    case 'POST':
      this.save(ctx, ctx.done);
    break;
    case 'DELETE':
      this.remove(ctx, ctx.done);
    break;
  }
}

AnswerCollection.dashboard = Collection.dashboard;

